<?php
/*************************************************************************************************#
# www.rf-cloning.org
#
# Copyright (C) 2009-2014 Steve R. Bond <biologyguy@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as published by
# the Free Software Foundation <http://www.gnu.org/licenses/>
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#*************************************************************************************************/
//Required POST parameters: 'svg_text' is well formed XML, 'div_id' is used as the svg object name and is where the image will be drawn, 'width', and 'height'.
//functions to generate Raphael code for the various svg elements. Should be able to handel most basic stuff, including the weirdness generated by illustrator.
function svg_line($node, $div_id)
	{		
	$output = "";
	$points = $node->attributes();
	$output .= "svg_".$div_id.".path('M".$points['x1']." ".$points['y1']."L".$points['x2']." ".$points['y2']."').attr({";
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'x1' && $attrib != 'x2' && $attrib != 'y1' && $attrib != 'y2')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);	
	}	

function svg_polyline($node, $div_id)
	{		
	$points = $node->attributes();
	$points = explode(" ",trim($points['points']));
	$first_points = explode(",", array_shift($points));
	$output = "svg_".$div_id.".path('M".$first_points[0]." ".$first_points[1];
	foreach ($points as $i)
		{
		$next = explode(",", $i);
		$output .= "L".$next[0]." ".$next[1];
		}
	$output .= "').attr({";	
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'points')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);
	}

function svg_path($node, $div_id)
	{		
	$points = $node->attributes();
	$output = "svg_".$div_id.".path('".$points['d']."').attr({";
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'd')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);
	}

function svg_text($node, $div_id)
	{		
	$points = $node->attributes();
	if(isset($points['transform']))
		{
		$holder = substr($points['transform'],7);
		$holder = preg_replace("/[)]/i","",$holder);	
		$holder = explode(" ",$holder);
		$x = $holder[4];
		$y = $holder[5];
		}
	else
		{
		$x = $points['x'];
		$y = $points['y'];
		}
	
	$output = "svg_".$div_id.".text(".$x.",".$y.",'".$node[0]."').attr({";
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'x' && $attrib != 'y' && $attrib != 'transform')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);
	}

function svg_circle($node, $div_id)
	{		
	$points = $node->attributes();
	$output = "svg_".$div_id.".circle(".$points['cx'].",".$points['cy'].",".$points['r'].").attr({";
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'cx' && $attrib != 'cy' && $attrib != 'r')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);
	}

function svg_rect($node, $div_id)
	{		
	$points = $node->attributes();
	$output = "svg_".$div_id.".rect(".$points['x'].",".$points['y'].",".$points['width'].",".$points['height'].").attr({";
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'x' && $attrib != 'y' && $attrib != 'width' && $attrib != 'height')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);
	}

function svg_ellipse($node, $div_id)
	{		
	$points = $node->attributes();
	$output = "svg_".$div_id.".ellipse(".$points['cx'].",".$points['cy'].",".$points['rx'].",".$points['ry'].").attr({";
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'cx' && $attrib != 'cy' && $attrib != 'rx' && $attrib != 'ry')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);
	}

function svg_polygon($node, $div_id)
	{		
	$points = $node->attributes();
	$points = explode(" ",trim($points['points']));
	$first_points = explode(",", array_shift($points));
	$output = "svg_".$div_id.".path('M".$first_points[0]." ".$first_points[1];
	foreach ($points as $i)
		{
		$next = explode(",", $i);
		@$output .= "L".$next[0]." ".$next[1];
		}
	$output .= "Z').attr({";	
	foreach ($node->attributes() as $attrib => $attrib_value)
		{
		if ($attrib != 'points')
			{
			$output .= "'".$attrib."':'".$attrib_value."', ";
			}
		}
	$output .= "});\n";
	$output = preg_replace("/, }/","}",$output);
	return($output);
	}		

function select_type($node, $div_id)
	{
	$output = "";
	//recursive function to get nested nodes
	if(count($node->children()) != 0)
		{
		foreach($node as $childnode)
			{
			$output .= select_type($childnode, $div_id);
			}
		}
	//select the appropriate function for the given feature
	else	
		{
		//first, clean up any extra whitespace inside the attributes list.
		foreach ($node->attributes() as $attrib => $attrib_value)
			{
			$attrib_value = preg_replace("/[\r\n\t]/i","",$attrib_value);
			$node->attributes($attrib) -> href = $attrib_value;
			}
		
		switch ($node->getName())
			{
			case "line":
				{
				$output .= svg_line($node, $div_id);
				break;	
				}
			
			case "polyline":
				{
				$output .= svg_polyline($node, $div_id);
				break;	
				}
			case "path":
				{
				$output .= svg_path($node, $div_id);
				break;	
				}
			case "text":
				{
				$output .= svg_text($node, $div_id);
				break;	
				}
			case "circle":
				{
				$output .= svg_circle($node, $div_id);
				break;	
				}
			case "rect":
				{
				$output .= svg_rect($node, $div_id);
				break;	
				}
			case "ellipse":
				{
				$output .= svg_ellipse($node, $div_id);
				break;	
				}
			case "polygon":
				{
				$output .= svg_polygon($node, $div_id);
				break;	 
				}
			}
		}
	return($output);
	}


//Set the starting stuff
$svg_obj = simplexml_load_string(stripslashes($_POST['svg_text']));	
$div_id = $_POST['div_id'];
$width = $_POST['width'];
$height = $_POST['height'];
$final_output = "";
//$final_output = "svg_".$div_id." = new Raphael('".$div_id."', ".$width.", ".$height.");\n";

//loop through the xml and call the appropriate function for each node.
foreach($svg_obj as $node)
	{
	$final_output .= select_type($node, $div_id);
	}
//echo "<textarea cols='100' rows='100'>".$final_output."</textarea>"; //This is for debugging...
echo $final_output;
?>